Fonction getId
5 versions g√©n√©r√©es par ChatGPT
Fonction qui prend un entier i (1,2,3 ‚Ä¶) et renvoie une cha√Æne de caract√®res (A, B, ‚Ä¶, Z, AA, 
AB, ‚Ä¶)
VERSION 1    
: variable mutable 
def getID(i: Int): String = {
  val builder = new StringBuilder
  var x = i
  // Ajuster pour base 1 
‚Üí
 0 interne
  while (x > 0) {
    val rem = (x - 1) % 26
    builder.append(('A' + rem).toChar)
    x = (x - 1) / 26
  }
  builder.reverse.toString
}
Explication rapide
‚Ä¢ On d√©cr√©mente x de 1 pour passer en base 0.
‚Ä¢ √Ä chaque √©tape, on calcule le reste modulo 26 pour obtenir une lettre.
‚Ä¢ On accumule les lettres dans un StringBuilder.
‚Ä¢ Enfin on inverse la cha√Æne (reverse) car les lettres sont calcul√©es en sens inverse.
Exemples
println(getID(1))   // A
println(getID(26))  // Z
println(getID(27))  // AA
println(getID(52))  // AZ
println(getID(53))  // BA
VERSION 2    
: purement fonctionnelle 
Voici une version purement fonctionnelle de la fonction getID, sans var ni StringBuilder, en 
utilisant seulement des expressions et de la r√©cursion :
def getID(i: Int): String = {
  def loop(x: Int, acc: List[Char]): List[Char] = {
    if (x <= 0) acc
    else {
      val rem = (x - 1) % 26
      val letter = ('A' + rem).toChar
      loop((x - 1) / 26, letter :: acc)
    }
  }
  loop(i, Nil).mkString
}
Comment √ßa marche (version fonctionnelle)
‚Ä¢ La fonction interne loop fait toute la logique par r√©cursion.
‚Ä¢ acc est une liste de caract√®res accumul√©s dans l‚Äôordre correct.
‚Ä¢ Quand x <= 0, on a fini et on retourne la liste.
‚Ä¢ On utilise letter :: acc pour ajouter une lettre devant la liste accumul√©e.
‚Ä¢ Enfin mkString convertit la liste en String.
Exemples d‚Äôutilisation
println(getID(1))   // A
println(getID(26))  // Z
println(getID(27))  // AA
println(getID(701)) // ZY
VERSION 3    
: it√©rative purement fonctionnelle  avec  Iterator 
def getID(i: Int): String = {
  val iter: Iterator[Char] = Iterator.unfold(i) { x =>
    if (x <= 0) None
    else {
      val rem = (x - 1) % 26
      val letter = ('A' + rem).toChar
      val next = (x - 1) / 26
      Some(letter, next)
    }
  }
  iter.toList.reverse.mkString
}
Comment √ßa fonctionne
‚Ä¢ Iterator.unfold(i)(f) g√©n√®re une s√©quence √† partir d‚Äôun √©tat x.
‚Ä¢ √Ä chaque √©tape, on produit une lettre et un nouvel √©tat (le quotient).
‚Ä¢ Quand x <= 0, l‚Äôit√©ration s‚Äôarr√™te.
‚Ä¢ On inverse ensuite la liste avec reverse pour obtenir l‚Äôordre correct.
Exemples
println(getID(1))   // A
println(getID(26))  // Z
println(getID(27))  // AA
println(getID(52))  // AZ
println(getID(703)) // AAA
VERSION 4    
: fonctionnelle avec  LazyList  (paresseux) 
def getID(i: Int): String = {
  // LazyList qui g√©n√®re les lettres √† partir d‚Äôun √©tat
  lazy val letters: LazyList[(Char, Int)] = LazyList.unfold(i) { x =>
    if (x <= 0) None
    else {
      val rem    = (x - 1) % 26
      val letter = ('A' + rem).toChar
      val next   = (x - 1) / 26
      Some((letter, next))
    }
  }
  letters.map(_._1).reverse.mkString
}
Comment √ßa marche
‚Ä¢ LazyList.unfold(i) part de l‚Äô√©tat initial i.
‚Ä¢ √Ä chaque √©tape, on √©met une lettre (Char) et on calcule le nouvel √©tat (next).
‚Ä¢ Quand l‚Äô√©tat devient ‚â§ 0, la g√©n√©ration s‚Äôarr√™te.
‚Ä¢ On prend ensuite les lettres g√©n√©r√©es, on inverse l‚Äôordre, et on transforme en cha√Æne.
Exemples d‚Äôutilisation
println(getID(1))   // A
println(getID(26))  // Z
println(getID(27))  // AA
println(getID(52))  // AZ
println(getID(703)) // AAA
‚úÖ
 Cette version est 
VERSION 5    
paresseuse et fonctionnelle, sans variables mutables.
: fonctionnelle avec  tail-recursive optimis√©e 
version fonctionnelle optimis√©e, tail-recursive (sans accumulation de grande structure 
interm√©diaire), tout en restant claire et idiomatique :
def getID(i: Int): String = {
  @annotation.tailrec
  def loop(x: Int, acc: List[Char]): List[Char] = {
    if (x <= 0) acc
    else {
      val rem    = (x - 1) % 26
      val letter = ('A' + rem).toChar
      loop((x - 1) / 26, letter :: acc) // ajoute en t√™te
    }
  }
  loop(i, Nil).mkString
}
Pourquoi c‚Äôest optimis√©
‚úÖ Tail-recursive : la derni√®re op√©ration dans la fonction est l‚Äôappel r√©cursif 
optimiser la pile.
‚úÖ Fonctionnel : pas de var, pas de mutation.
Exemples
println(getID(1))   // A
println(getID(26))  // Z
println(getID(27))  // AA
println(getID(52))  // AZ
println(getID(703)) // AAA
‚Üí
 Scala peut 
VERSION 6    
: fonctionnelle avec  tail-recursive optimis√©e en base quelconque 
G√©n√©ralisation dans une base arbitraire (pas seulement base 26) ‚Äî par exemple pour base 2, 16, 
32, 36 ou m√™me une base personnalis√©e avec n‚Äôimporte quel alphabet.
üìå Rappel math√©matique : pour repr√©senter un entier dans une base b‚â•2, on utilise la m√©thode 
des divisions successives par la base, en collectant les restes du moins significatif au plus 
significatif, puis on lit ces restes √† rebours pour former la repr√©sentation en cha√Æne. 
 1) Conversion vers une base quelconque
‚úÖ
Voici une fonction Scala g√©n√©rique qui prend :
‚Ä¢ un entier n: BigInt (pour g√©rer grands nombres),
‚Ä¢ un alphabet personnalis√© (String) o√π chaque caract√®re repr√©sente un ‚Äúchiffre‚Äù de la base,
et retourne la repr√©sentation de n dans cette base :
def toBase(n: BigInt, alphabet: String): String = {
  require(alphabet.length >= 2, "La base doit avoir au moins 2 symboles")
  @annotation.tailrec
  def loop(x: BigInt, acc: List[Char]): List[Char] = {
    if (x == 0) acc
    else {
      val base = BigInt(alphabet.length)
      val (q, r) = x /% base
      loop(q, alphabet(r.toInt) :: acc)
    }
  }
  if (n == 0) alphabet.head.toString
  else loop(n, Nil).mkString
}
üß†
 Comment √ßa marche
‚Ä¢ alphabet d√©finit les ‚Äúchiffres‚Äù dans l‚Äôordre, par exemple "0123456789ABCDEF" pour base 16
ou "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" pour base 36. Reddit
‚Ä¢ On divise n par la taille de l‚Äôalphabet (donc la base) et on r√©cup√®re les restes (r) √† 
chaque √©tape.
‚Ä¢ Chaque reste donne une position dans l‚Äôalphabet 
‚Üí
 on accumule ces caract√®res.
‚Ä¢ Puis on inverse la liste de caract√®res pour obtenir le bon ordre.
üéØ
 2) Exemples d‚Äôutilisation
val base2  = "01"
val base16 = "0123456789ABCDEF"
val base32 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"  // RFC 4648 Base32
val base36 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
println(toBase(BigInt(255), base2))   // "11111111"
println(toBase(BigInt(255), base16))  // "FF"
println(toBase(BigInt(123456), base32)) 
println(toBase(BigInt(123456), base36)) 
ÔøΩ
ÔøΩ
 Tu peux d√©finir 
n‚Äôimporte quel alphabet personnalis√©, tant qu‚Äôil contient au moins 2 
symboles.
 Personnaliser l‚Äôalphabet
üõ†
Ô∏è
Tu veux une base 26 (A‚Ä¶Z) mais sans chiffres 0‚Ä¶9 ? Voici l‚Äôalphabet :
val base26Letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
Alors :
println(toBase(BigInt(27), base26Letters)) // "AB"
üí°
 Notes techniques
‚Ä¢ L‚Äôalgorithme repose sur une conversion positionnelle, identique √† celle utilis√©e pour la 
conversion de bases en g√©n√©ral (par exemple base 10 
‚Üí
 base 2 ou base 16). 
digischool
‚Ä¢ En choisissant bien l‚Äôalphabet, tu peux couvrir jusqu‚Äô√† base 36 (0-9 + A-Z) ou bien tout 
autre encodage (base 62 avec minuscules et majuscules, etc.).